# PP_ActionRPG

[![Video Label](http://img.youtube.com/vi/BnBJfVo4on0/0.jpg)](https://youtu.be/BnBJfVo4on0)
<br>사진을 누르면 해당 영상을 확인하실 수 있습니다. </br>


# 📌 프로젝트 개요

| 항목 | 내용 |
| --- | --- |
| 프로젝트명 | TPS Action RPG  |
| 장르 | 3인칭 Action |
| 플랫폼 | PC |
| 개발 기간 | 2024.06 ~ 2024.10 |
| 개발 인원 | 1명 (개인 프로젝트) |
| 역할 | 기획, 클라이언트 프로그래밍, UI |

# 🧩 주요 시스템 및 기능

---

## 🔹Custom Editor - Pose Copy

### 🌀 특정 행동을 재현하는 마네킹 기능 구현

### 🔍 문제 배경

스킬 기능 연출에서 특정한 모션을 취한 채 유지되는 모델이 여럿 필요할 때, 

애니메이션의 특정 프레임 동작을 정확히 고정하는 상태로 재현하는 작업이 필요했다. 

하지만 기존 방식에서는

- 타임라인 스크럽 → Transform 수기 봇가 → 재적용 과정 반복
- 반복 작업이 많고, 실수 가능성 높으며 작업 피로도가 매우 큼
- 특정 프레임 고정 포즈 재현이 너무 번거로운 일이라는 피드백 발생

### 🎯 기획 의도 및 고민 방향

- 선택한 애니메이션 클립에서 현재 포즈를 그대로 복제하는 방향
- 선택한 오브젝트의 Trasnform 정보를 자동 추출 및 저장
- 직관적인 Custom Editor UI를 제공하여 클릭 몇 번으로 가능하게 구성

### 🧩 해결 방안 및 구현 내용

| 기술 요소 | 설명 |
| --- | --- |
| `EditorWindow` | 독립된 툴 창 생성 |
| `SerializedObject` | 대상 오브젝트에 접근 및 조작 |
| `SerializedProperty` | 각 트랜스폼 속성 직접 수정 가능 |
| `Animator` + `Avatar` | 현재 포즈 정보 추출에 사용 |

UI 기능

- “Play Selected Frame” 버튼 클릭 시, 해당 애니메이션의 Transform 값으로 처리되어 행동 변경
- “Copy and Create New” 버튼 클릭 시, 지정한 프레임의 모습대로 새로운 게임 오브젝트 생성

### 👁️‍🗨️ 결과 및  효과

- 적은 회수의 클릭으로 포즈 복제 가능
- 복잡하고 반복적이던 과정을 툴로 대체하여 생산성 대폭 향상

<img src ="https://github.com/user-attachments/assets/7b5bcbd9-8577-4781-badf-03ecced7f2a7" width = 400>

---

## 🔹Custom Editor - Blackboard Editor

### 🌀 AI Behavior Tree의 로직을 결정 짓는 Blackboard 설계

### 🔍 문제 배경

기존 AI 로직을 개선하기 위해 채택한 Behaviour Tree 모델을 도입하기 위해 언리얼 엔진의 Behavior Tree를 모방했으며 그 중 Blackboard 시스템을 모방하는 중에 다음과 같은 문제 발생

- Blackboard  값을 설정하는데  비직관성 → 에디터에서 설정하지 못 한 채 직접 코드에서 설정해야함
- 다양한 자료형 지원 되지 않는 문제 → 에디터에서 설정하게 되면 사용자 지정 자료형은 노출되지 않은 문제 발생

### 🎯 기획 의도 및 고민 방향

- 언리얼 엔진의 Blackboard를 모방하여 구현 중
    
    → 사용자가 직접 Key를 추가하는 과정이 직관적이지 않은 문제
    
- 다양한 자료형의 Key를 지원해야 했지만, 자료형별 처리 방식이 중복되거나 불일치
- 런타임/데이터 간 데이터 동기화, Key 직렬화 등에서 유지보수에 부담이 있음

### 🧩 해결 방안 및 구현 내용

1. 전략 패턴 기반 자료형 분리 
    - 각 자료형 Key 처리 로직을 독립 전략 클래스로 분리
    - Key 추가, 검증, 출력 등 모든 행위를 공통 인터페이스 기반으로 분리하여 일관성 확보
2. AttributeUsage를 활용한 사용자 정의 Key 등록
    - 사용자 클래스를 통해 직접 Key를 정의할 수 있도록 `BlackboardKeyAttribute` 커스텀 속성 생성
    - 리플렉션을 활용하여 해당 Attribute가 부착된 필드를 자동 탐지 및 등록
    - Key 목록은 자동 직렬화되어 저장되며, 수작업 설정없이 사용 가능
3. Custom Editor 기능 구현
    - Unity 의 `EditorWindow`  혹은 `PropertyDrawer` 를 활용해 에디터 상에서 Key를 직접 편집, 추가, 삭제 가능하게 구현
    - Key Type 드롭다운, Default 값 설정 UI, 유효성 체크 포함
    - 런타임 중에도 Blackboard 내용을 시각적으로 디버깅 가능

### 👁️‍🗨️ 결과 및  효과

- 자료형 별 Key 처리 일관성 확보
    
    → 전략 패턴으로 유지보수성 향상
    
- 사용자 정의 Key 확장성 보장
    
    → Attribute 기반 정의로 코드 재사용 가능
    
- 에디터 통합 관리 도구 제공
    
    → 데이터 입력 및 검증을 시각적으로 처리 → 실수 및 생산성 문제 해결 
    
<img src ="https://github.com/user-attachments/assets/fb5eb8de-33dd-4a41-be24-7b91eb684a1a" width = 400>
---

## 🔹Custom Editor - Behavior Tree Editor

### 🌀 AI Behavior Tree를 시각적으로 구성할 수 있는 Editor 설계

### 🔍 문제 배경

- FSM의 문제점을 해결하기 위해 Behavior Tree 모델로 설계
- Behavior Tree 를 코드로만 작성해야하는 비효율성 발생
    
    → 복잡한 로직일 수록 구조 파악이 어려움
    
- 노드 간 연결, 조건, 상태 등이 한 눈에 파악이 어려움 발생

### 🎯 기획 의도 및 고민 방향

- FSM을 대변하기 위한 Behavior Tree를 도입할 때 유의할 점
- Behavior Tree의 각 노드들을 어떻게 구성할 것인가
- Behavior Tree를 쉽게 조작하기 위한 커스텀 에디터 구현

### 🧩 해결 방안 및 구현 내용

1. Custom Editor 기반 Behavior Tree 시각화 도구 개발 
    - `Unity Editor.GraphView` 기반 시각화 EditorWindow 구성
    - 드래그 앤 드롭 방식으로 노드 추가 / 연결 / 삭제 기능 제공
2. ScriptableObject 기반 트리 구성
    - 각 Node는 ScriptableObject로 정의
    - 트리 구성 시 각 노드는 독립된 자산으로 저장되며, 재사용 및 참조가 용이
3. 런타임 연동
    - 런타임 중 노드의  실행 상태, 트리 상태를 실시간으로 모니터링 가능한 구조 설계

### 👁️‍🗨️ 결과 및  효과

- 작업 속도 향상 : 복잡한 트리를 시각적으로 구성 가능
- 가독성/관리성 향상 : 전반적인 트리 구조를 한 눈에 파악 가능
- 재사용성 평가 : ScriptableObject를 통해 노드 단위 저장/불러오기 가능
- 학습 곡선 완화 : 신입 개발자나 디자니어도 쉽게 접근 가능

<img src ="https://github.com/user-attachments/assets/72ed38df-22b8-481a-bb25-086d96b9fb4d" width = 400>

---

## 🔹AI System

### 🌀 Behavior Tree 기반으로 동작하는 AI 구현

### 🔍 문제 배경

초기 AI는 FSM을 기반으로 설계했으나 점점 상태가 많아 지고 다양한 패턴을 구하기 위해서 한 상태에 여러 상태들이 새로 추가될 때마다 코드가 복잡해지고 확장성및 유지보수성이 낮아지는 문제 발생 

### 🎯 기획 의도 및 고민 방향

- 기존 FSM이나 단순 스크립팅 기반에서는 AI 상태 전환이 불안정하거나 비효율적
- 특정 AI에만 맞춰진 구조는 다른 대상에 적용하기 어렵고 유지보수가 힘듬
- 복잡한 AI 구조는 로직의 확장성, 가독성, 재사용성에 취약

### 🧩 해결 방안 및 구현 내용

1. Behavior Tree 기반 구조 구현
    - 기능 단위로 분리된 노드 구성 → 읽기 쉬운 트리 구성
    - 행동을 세분화하여 트리 구성 시 조합으로 복잡한 행동 설계 가능
2. State Pattern과 병행하여 유연한 상태 전환 구조 구축
    - 상태마다 다른 트리 로딩 및 실행 가능
3. 추상화와 상속 구조 설계
    - `Node` 를 추상화하고, `Composite`, `Task`, `Decoraotr`는 세부 구현 클래스에서 상속
    - AI 마다 다른 특성이 필요한 경우 커스텀 노드마 추가로 구한하면 적용 가능

### 👁️‍🗨️ 결과 및  효과

- 재사용성 강화 : 여러 AI가 공통된 구조를 사용하므로 설계 일관성 확보
- 상태 전환이 직관적이고 안정적
- 확장 용이성 : 새로운 행동 추가 시 기존 노드 구조를 훼손하지 않고 쉽게 확장 가능
- 유지보수성 향상 : 트리 노드 단위 디버깅이 가능

---

## 🔹Combo System

### 🌀 애니메이션 기반 콤보 입력 처리 기능 개선

### 🔍 문제 배경

기존 전투 시스템에서는 콤보 입력이 애니메이션 이벤트 타이밍에 종속되어 있었다. 

이로 인해 애니메이션 시간이 짧을 경우, 다음 입력을 받기 어려운 현상이 발생함.

### 🎯 기획 의도 및 고민 방향

- 플레이어가 리듬감 있게 입력을 이어가는 코보 시스템 구현을 목표
- 애니메이션과 입력 타이밍 사이의 간극을 줄여, 입력 반응성을 강화하고 몰입감있는 전투 흐름 제공을 의도
- 반복적인 타격과 입력을 자연스럽게 이어갈 수 있는 구조 설계를 고민

### 🧩 해결 방안 및 구현 내용

- ComboComponent 생성
    - 콤보 입력을 관리하는 독립 컴포넌트 설계
    - 콤보 타이밍, 입력 버퍼 등의 값을 컴포넌트 내부에서 처리
- ScriptableObject 기반 콤보 정의
    - 각 콤보 패턴을 ScriptableObject로 정의하여 데이터 중심 설계 구현
    - 콤보 이름, 애니메이션, 입력 타이밍 등의 데이터를 외부에서 손쉽게 관리
- Queue 기반 입력 버퍼링
    - 입력 타이밍을 큐(Queue)로 저장하여 유예 시간 동안 입력을 허용
    - 빠른 애니메이션에도 사용자가 미리 입력한 키를 시스템이 감지하여 다음 동작으로 자연스럽게 연결

### 👁️‍🗨️ 결과 및  효과

- 애니메이션 속도와 무관하게 입력 타이밍 유연성 확보
    - 짧은 모션에서도 콤보가 매끄럽게 이어짐
- ScriptableObject로 콤보 패턴 외부화
    - 데이터 기반으로 콤보 정의
- 버퍼링 큐 처리로 입력 유실 최소화
    - 플레이어가 의도한 대로 연속적인 타격 발생
- 전투 흐름 개선 및 몰입도 강화

---

## 🔹충돌 판정 개선

### 🌀 공격 궤적을 추가로 검사하여 안정적인 검사 기능

### 🔍 문제 배경

공격 애니메이션 도중 일부 타격이 정상적으로 판정되지 않는 문제가 반복적으로 발생.

특히 공격 궤적이 빠르게 지나가거나 모션이 큰 경우, 판정 타이밍이 애니메이션 프레임에 종속되어 히트 누락이 발생하는 현상이 두드러짐

### 🎯 기획 의도 및 고민 방향

- 실제 궤적을 따라가는 판정 시스템 구현을 목표로 함.
- 플레이어가 공격한 궤적에 따라 적절한 히트 리액션이 발생하도록 정밀한 판정 강화
- 빠른 모션, 공중 공격, 다단 히트 기술 등 다양한 연출 상황에서도 일관된 충돌 판정 제공을 고민

### 🧩 해결 방안 및 구현 내용

- 궤적 기반 Ray 검사 추가
    - 공격 애니메이션의 궤적을 따라가는 방식으로 Ray를 생성하여 충돌 판정 수행
    - 매 프레임마다 일정 간격으로 Ray를 쓰고 충돌 여부를 확인하여 누락 방지
- AttackTraceComponent 설계
    - 공격 판정을 처리하는 전용 컴포넌트 구현
    - 위치 기반이 아닌 궤적 기반으로 판정 영역을 동적으로 형성
    - 공중 공격, 범위 공격 등 다양한 상황을 고려한 다중 Trace 설계 가능

### 👁️‍🗨️ 결과 및  효과

- 빠른 공격 모션에서도 히트 판정 누락 방지
- 궤적 기반 판정으로 현실감 및 연출 개선
- 기존 애니메이션 프레임 의존성 제거

---

## 🔹무기 관리

### 🌀 WeaponComponent 추상화 및 인터페이스 분리 설계

### 🔍 문제 배경

초기에는 WeaponComponent를 통해 모든 무기 관련 기능을 통합하여 무기의 설정 및 커맨드 중계를 담당하는 구조로 설계됨

- 플레이어든 AI든 무기를 장착하면, 해당 컴포넌트가 애니메이션 무기 기준으로 전송하는 역할 수행
- 무기별 커맨드 및 애니메이션 동작의 일관성을 확보할  수 있으나 모든 캐릭터가 무기를 장착하지 않는 문제 발생

### 🎯 기획 의도 및 고민 방향

- 무기를 장착하지 않은 AI에게도 공격 기능이 필요
- 기존 시스템에서는 WeaponComponent에 의존하므로 무기 없는 캐릭터는 불가 상태가 되는 구조적 문제 발생
- 무기를 사용하는 객체와 사용하지 않는 객체 모두에게 공통 인터페이스 제공이 필요

### 🧩 해결 방안 및 구현 내용

- Weapon 클래스 구조 재정비
    - Weapon 클래스는 공격/스킬 등 행동 단위에 대한 추상화 담당
    - 각 무기는 해당 클래스를 상속하여 특정 애니메이션 트리거 및 커맨드를 구현
- WeaponComponent → 역할 분리
    - 커맨드 전달/입력 감지 역할은 별도로 추출
    - `WeaponComponent`는 오직 무기 장비된 캐릭터에게만 장착
- 공통 인터페이스 분리
    - `IActionable` 인터페이스 정의
        - 무기 보유 여부 상관없이 같은 메서드 호출 가능

### 👁️‍🗨️ 결과 및  효과

- 무기 장착 여부에 관계없이 공격 로직 통합 관리 가능
- 무기 기능만 추출해 재사용성 향상
- 유지보수성 향상
    - 게임 로직 일관성 강화

---

## 🔹Launch & Airborne 시스템 리팩토링

### 🌀 입력을 받으면 이벤트에 따른 콤보 처리

### 🔍 문제 배경

초기 시스템에서는 Launch와 Ariborne 기능을 하나의 클래스에서 통합적으로 구현함.

- 두 기능 모두 공중 상태와 관련되어 있어 통합 구현이 자연스러워 보였으나 시간이 지남에 따라 낙하 중 피격, 낙하 속도 제어, 공중 콤보 처리 등 기능이 추가될 때마다 서로의 기능이 충돌
- 특정 기능이 의도하지 않게 비활성되는 문제 발생.

### 🎯 기획 의도 및 고민 방향

- Launch : 적이나 플레이어를 공중으로 띄우는 초기 동작
- Airborne : 띄워진 이후의 상태 처리

이 두 시스템을 통합 구현하면 제어 로직이 얽히고, 유지보수가 극도로 어려워지기 때문에 이를 보안할 방법이 필요하다.

### 🧩 해결 방안 및 구현 내용

- 단일 책임 원칙 적용 (SRP)
    - LaunchComponent : 띄우기 로직만 전담
        - 띄우기 전 피격 무효화, 초기 힘 적용 등
    - AirborneComponent : 공중 상태 처리 전달
        - 공중 유지 시간, 낙하 감속, 상태 전환 처리
- 각 컴포넌트는 독립적 동작
    - 두 컴포넌트는 서로 의존하지 않음
    - 캐릭터는 Launch → Aiborne의 흐름만 제어

### 👁️‍🗨️ 결과 및  효과

- 기능 분리로 유지보수성 대폭 향상
- 각 기능 확장 용이
- 게임 내 캐릭터 상태 전이 흐름이 명확해짐

---

## 🧠 기술적 고민 & 해결 사례

| 주제 | 고민 | 해결 방법 | 결과 |
| --- | --- | --- | --- |
| 대시 중 회피 판정 구현 | 효과를 적용할 특정 대상을 찾는 등의 기능 추가로 클래스의 크기가 비대해짐 | 인터페이스를 이용하여 특정 대상에게 적용하도록 처리 | 인터페이스 사용으로 유지보수성 향상 |
